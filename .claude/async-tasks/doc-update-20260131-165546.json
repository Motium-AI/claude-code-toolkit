{
  "type": "doc-update",
  "created_at": "2026-01-31T16:55:46.080292+00:00",
  "status": "pending",
  "commit_message": "feat(memory): close feedback loop \u2014 injection logging, utility tracking, MIN_SCORE auto-tune\n\nAdd memory_that_helped checkpoint field, per-event utility tracking in\nmanifest, and proportional controller for MIN_SCORE auto-tuning. Events\ninjected 3+ times with zero citations get demoted. Controller bounded\n[0.05, 0.25] with 20-injection minimum before activation.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>",
  "diff_content": "commit 8774856350a387e14752eac5298d55e84284ee6c\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Sat Jan 31 17:55:45 2026 +0100\n\n    feat(memory): close feedback loop \u2014 injection logging, utility tracking, MIN_SCORE auto-tune\n    \n    Add memory_that_helped checkpoint field, per-event utility tracking in\n    manifest, and proportional controller for MIN_SCORE auto-tuning. Events\n    injected 3+ times with zero citations get demoted. Controller bounded\n    [0.05, 0.25] with 20-injection minimum before activation.\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_memory.py                 | 136 ++++++++++++++++++++++++++++++++\n config/hooks/_sv_templates.py           |   6 +-\n config/hooks/compound-context-loader.py |  43 +++++++++-\n config/hooks/stop-validator.py          |  56 +++++++++++++\n 4 files changed, 236 insertions(+), 5 deletions(-)\n\ndiff --git a/config/hooks/_memory.py b/config/hooks/_memory.py\nindex c6ac5e5..79dd550 100644\n--- a/config/hooks/_memory.py\n+++ b/config/hooks/_memory.py\n@@ -379,4 +379,140 @@ def cleanup_old_events(cwd: str) -> int:\n             hook_name=\"memory\",\n         )\n \n+    # Prune stale utility entries for deleted events\n+    _cleanup_stale_utility(event_dir)\n+\n     return removed\n+\n+\n+# ============================================================================\n+# Utility Tracking (Feedback Loop)\n+# ============================================================================\n+\n+\n+def _get_utility_from_manifest(cwd: str) -> dict:\n+    \"\"\"Read utility data from manifest. Returns empty dict if missing.\"\"\"\n+    event_dir = get_memory_dir(cwd)\n+    manifest_path = event_dir.parent / MANIFEST_NAME\n+    try:\n+        if manifest_path.exists():\n+            manifest = json.loads(manifest_path.read_text())\n+            return manifest.get(\"utility\", {})\n+    except (json.JSONDecodeError, IOError, OSError):\n+        pass\n+    return {}\n+\n+\n+def record_utility(cwd: str, injected_ids: list[str], helped_ids: set[str]) -> None:\n+    \"\"\"Record injection/citation counts for utility tracking.\n+\n+    Called by stop-validator after validating memory_that_helped against\n+    the injection log. Updates manifest.utility with per-event and\n+    aggregate counters.\n+    \"\"\"\n+    event_dir = get_memory_dir(cwd)\n+    manifest_path = event_dir.parent / MANIFEST_NAME\n+    try:\n+        manifest = {}\n+        if manifest_path.exists():\n+            raw = manifest_path.read_text()\n+            if raw.strip():\n+                manifest = json.loads(raw)\n+\n+        utility = manifest.get(\"utility\", {})\n+        events_util = utility.get(\"events\", {})\n+\n+        for eid in injected_ids:\n+            entry = events_util.get(eid, {\"injected\": 0, \"cited\": 0})\n+            entry[\"injected\"] = entry.get(\"injected\", 0) + 1\n+            if eid in helped_ids:\n+                entry[\"cited\"] = entry.get(\"cited\", 0) + 1\n+            events_util[eid] = entry\n+\n+        utility[\"events\"] = events_util\n+        utility[\"total_injected\"] = utility.get(\"total_injected\", 0) + len(injected_ids)\n+        utility[\"total_cited\"] = utility.get(\"total_cited\", 0) + len(helped_ids)\n+        manifest[\"utility\"] = utility\n+\n+        atomic_write_json(manifest_path, manifest)\n+    except (json.JSONDecodeError, IOError, OSError) as e:\n+        log_debug(f\"record_utility failed: {e}\", hook_name=\"memory\")\n+\n+\n+def get_event_demotion(cwd: str, event_id: str) -> float:\n+    \"\"\"Return demotion factor (0.0-0.5) for events injected often with no citations.\n+\n+    Events injected 3+ times with 0 citations get a 0.5 demotion (50% score penalty).\n+    Events injected 2 times with 0 citations get 0.25.\n+    Otherwise returns 0.0 (no demotion).\n+    \"\"\"\n+    if not event_id:\n+        return 0.0\n+    utility = _get_utility_from_manifest(cwd)\n+    entry = utility.get(\"events\", {}).get(event_id)\n+    if not entry:\n+        return 0.0\n+    injected = entry.get(\"injected\", 0)\n+    cited = entry.get(\"cited\", 0)\n+    if cited > 0 or injected < 2:\n+        return 0.0\n+    if injected >= 3:\n+        return 0.5\n+    return 0.25  # injected == 2, cited == 0\n+\n+\n+def get_tuned_min_score(cwd: str, default: float = 0.12) -> float:\n+    \"\"\"Auto-tune MIN_SCORE based on aggregate citation rate.\n+\n+    Proportional controller: if citation rate is high, lower the threshold\n+    (inject more). If citation rate is low, raise the threshold (be pickier).\n+\n+    Requires 20+ total injections before activating. Clamped to [0.05, 0.25].\n+    \"\"\"\n+    utility = _get_utility_from_manifest(cwd)\n+    total_injected = utility.get(\"total_injected\", 0)\n+    if total_injected < 20:\n+        return default\n+\n+    total_cited = utility.get(\"total_cited\", 0)\n+    citation_rate = total_cited / total_injected  # 0.0 to ~1.0\n+\n+    # Target citation rate: 0.15 (15% of injected memories are cited)\n+    # If actual rate > target: lower threshold (inject more)\n+    # If actual rate < target: raise threshold (be pickier)\n+    target_rate = 0.15\n+    adjustment = (target_rate - citation_rate) * 0.3  # Gentle proportional control\n+    tuned = default + adjustment\n+\n+    return max(0.05, min(0.25, tuned))\n+\n+\n+def _cleanup_stale_utility(event_dir: Path) -> None:\n+    \"\"\"Prune utility entries for events that no longer exist.\n+\n+    Called during cleanup_old_events to keep utility data bounded.\n+    \"\"\"\n+    manifest_path = event_dir.parent / MANIFEST_NAME\n+    try:\n+        if not manifest_path.exists():\n+            return\n+        manifest = json.loads(manifest_path.read_text())\n+        utility = manifest.get(\"utility\", {})\n+        events_util = utility.get(\"events\", {})\n+        if not events_util:\n+            return\n+\n+        # Check which event IDs still have files\n+        existing_ids = {f.stem for f in event_dir.glob(\"evt_*.json\")}\n+        pruned = {eid: data for eid, data in events_util.items() if eid in existing_ids}\n+\n+        if len(pruned) < len(events_util):\n+            utility[\"events\"] = pruned\n+            manifest[\"utility\"] = utility\n+            atomic_write_json(manifest_path, manifest)\n+            log_debug(\n+                f\"Pruned {len(events_util) - len(pruned)} stale utility entries\",\n+                hook_name=\"memory\",\n+            )\n+    except (json.JSONDecodeError, IOError, OSError):\n+        pass\ndiff --git a/config/hooks/_sv_templates.py b/config/hooks/_sv_templates.py\nindex a6b4d29..f93b077 100644\n--- a/config/hooks/_sv_templates.py\n+++ b/config/hooks/_sv_templates.py\n@@ -34,7 +34,8 @@ GO_CHECKPOINT_SCHEMA_TEMPLATE = \"\"\"{version_note}\n     \"what_was_done\": \"...\",                  // >20 chars - what you actually did\n     \"what_remains\": \"none\",                  // Must be empty to allow stop\n     \"key_insight\": \"...\",                    // >30 chars: reusable lesson for FUTURE sessions. NOT what you did \u2014 what you LEARNED.\n-    \"search_terms\": []                       // 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"search_terms\": [],                      // 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"memory_that_helped\": []                 // Event IDs from <m> tags that helped this session (empty if none)\n   }}\n }}\"\"\"\n \n@@ -55,7 +56,8 @@ CHECKPOINT_SCHEMA_TEMPLATE = \"\"\"{version_note}\n     \"what_was_done\": \"...\",                 // Honest summary of work completed\n     \"what_remains\": \"none\",                 // Must be empty to allow stop\n     \"key_insight\": \"...\",                   // REQUIRED >30 chars: reusable lesson for FUTURE sessions. NOT what you did \u2014 what you LEARNED.\n-    \"search_terms\": []                      // REQUIRED 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"search_terms\": [],                     // REQUIRED 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"memory_that_helped\": []              \n\n... [truncated - diff too long]",
  "existing_docs": [
    "docs/architecture.md",
    "docs/analysis-persistent-memory-for-harnesses.md",
    "docs/index.md",
    "docs/memory-integration-analysis.md",
    "docs/philosophy.md",
    "docs/audiobook-the-amnesiac-architect.md",
    "README.md",
    ".claude/MEMORIES.md"
  ],
  "instructions": "\nDOCUMENTATION UPDATE TASK\n\nA commit was just made in an repair/build session. Your job is to:\n\n1. Analyze the diff to understand what changed\n2. Determine which documentation files need updating\n3. Update the relevant docs to reflect the changes\n\nCOMMIT MESSAGE:\nfeat(memory): close feedback loop \u2014 injection logging, utility tracking, MIN_SCORE auto-tune\n\nAdd memory_that_helped checkpoint field, per-event utility tracking in\nmanifest, and proportional controller for MIN_SCORE auto-tuning. Events\ninjected 3+ times with zero citations get demoted. Controller bounded\n[0.05, 0.25] with 20-injection minimum before activation.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\nEXISTING DOCUMENTATION FILES:\n- docs/architecture.md\n- docs/analysis-persistent-memory-for-harnesses.md\n- docs/index.md\n- docs/memory-integration-analysis.md\n- docs/philosophy.md\n- docs/audiobook-the-amnesiac-architect.md\n- README.md\n- .claude/MEMORIES.md\n\nDIFF CONTENT:\ncommit 8774856350a387e14752eac5298d55e84284ee6c\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Sat Jan 31 17:55:45 2026 +0100\n\n    feat(memory): close feedback loop \u2014 injection logging, utility tracking, MIN_SCORE auto-tune\n    \n    Add memory_that_helped checkpoint field, per-event utility tracking in\n    manifest, and proportional controller for MIN_SCORE auto-tuning. Events\n    injected 3+ times with zero citations get demoted. Controller bounded\n    [0.05, 0.25] with 20-injection minimum before activation.\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_memory.py                 | 136 ++++++++++++++++++++++++++++++++\n config/hooks/_sv_templates.py           |   6 +-\n config/hooks/compound-context-loader.py |  43 +++++++++-\n config/hooks/stop-validator.py          |  56 +++++++++++++\n 4 files changed, 236 insertions(+), 5 deletions(-)\n\ndiff --git a/config/hooks/_memory.py b/config/hooks/_memory.py\nindex c6ac5e5..79dd550 100644\n--- a/config/hooks/_memory.py\n+++ b/config/hooks/_memory.py\n@@ -379,4 +379,140 @@ def cleanup_old_events(cwd: str) -> int:\n             hook_name=\"memory\",\n         )\n \n+    # Prune stale utility entries for deleted events\n+    _cleanup_stale_utility(event_dir)\n+\n     return removed\n+\n+\n+# ============================================================================\n+# Utility Tracking (Feedback Loop)\n+# ============================================================================\n+\n+\n+def _get_utility_from_manifest(cwd: str) -> dict:\n+    \"\"\"Read utility data from manifest. Returns empty dict if missing.\"\"\"\n+    event_dir = get_memory_dir(cwd)\n+    manifest_path = event_dir.parent / MANIFEST_NAME\n+    try:\n+        if manifest_path.exists():\n+            manifest = json.loads(manifest_path.read_text())\n+            return manifest.get(\"utility\", {})\n+    except (json.JSONDecodeError, IOError, OSError):\n+        pass\n+    return {}\n+\n+\n+def record_utility(cwd: str, injected_ids: list[str], helped_ids: set[str]) -> None:\n+    \"\"\"Record injection/citation counts for utility tracking.\n+\n+    Called by stop-validator after validating memory_that_helped against\n+    the injection log. Updates manifest.utility with per-event and\n+    aggregate counters.\n+    \"\"\"\n+    event_dir = get_memory_dir(cwd)\n+    manifest_path = event_dir.parent / MANIFEST_NAME\n+    try:\n+        manifest = {}\n+        if manifest_path.exists():\n+            raw = manifest_path.read_text()\n+            if raw.strip():\n+                manifest = json.loads(raw)\n+\n+        utility = manifest.get(\"utility\", {})\n+        events_util = utility.get(\"events\", {})\n+\n+        for eid in injected_ids:\n+            entry = events_util.get(eid, {\"injected\": 0, \"cited\": 0})\n+            entry[\"injected\"] = entry.get(\"injected\", 0) + 1\n+            if eid in helped_ids:\n+                entry[\"cited\"] = entry.get(\"cited\", 0) + 1\n+            events_util[eid] = entry\n+\n+        utility[\"events\"] = events_util\n+        utility[\"total_injected\"] = utility.get(\"total_injected\", 0) + len(injected_ids)\n+        utility[\"total_cited\"] = utility.get(\"total_cited\", 0) + len(helped_ids)\n+        manifest[\"utility\"] = utility\n+\n+        atomic_write_json(manifest_path, manifest)\n+    except (json.JSONDecodeError, IOError, OSError) as e:\n+        log_debug(f\"record_utility failed: {e}\", hook_name=\"memory\")\n+\n+\n+def get_event_demotion(cwd: str, event_id: str) -> float:\n+    \"\"\"Return demotion factor (0.0-0.5) for events injected often with no citations.\n+\n+    Events injected 3+ times with 0 citations get a 0.5 demotion (50% score penalty).\n+    Events injected 2 times with 0 citations get 0.25.\n+    Otherwise returns 0.0 (no demotion).\n+    \"\"\"\n+    if not event_id:\n+        return 0.0\n+    utility = _get_utility_from_manifest(cwd)\n+    entry = utility.get(\"events\", {}).get(event_id)\n+    if not entry:\n+        return 0.0\n+    injected = entry.get(\"injected\", 0)\n+    cited = entry.get(\"cited\", 0)\n+    if cited > 0 or injected < 2:\n+        return 0.0\n+    if injected >= 3:\n+        return 0.5\n+    return 0.25  # injected == 2, cited == 0\n+\n+\n+def get_tuned_min_score(cwd: str, default: float = 0.12) -> float:\n+    \"\"\"Auto-tune MIN_SCORE based on aggregate citation rate.\n+\n+    Proportional controller: if citation rate is high, lower the threshold\n+    (inject more). If citation rate is low, raise the threshold (be pickier).\n+\n+    Requires 20+ total injections before activating. Clamped to [0.05, 0.25].\n+    \"\"\"\n+    utility = _get_utility_from_manifest(cwd)\n+    total_injected = utility.get(\"total_injected\", 0)\n+    if total_injected < 20:\n+        return default\n+\n+    total_cited = utility.get(\"total_cited\", 0)\n+    citation_rate = total_cited / total_injected  # 0.0 to ~1.0\n+\n+    # Target citation rate: 0.15 (15% of injected memories are cited)\n+    # If actual rate > target: lower threshold (inject more)\n+    # If actual rate < target: raise threshold (be pickier)\n+    target_rate = 0.15\n+    adjustment = (target_rate - citation_rate) * 0.3  # Gentle proportional control\n+    tuned = default + adjustment\n+\n+    return max(0.05, min(0.25, tuned))\n+\n+\n+def _cleanup_stale_utility(event_dir: Path) -> None:\n+    \"\"\"Prune utility entries for events that no longer exist.\n+\n+    Called during cleanup_old_events to keep utility data bounded.\n+    \"\"\"\n+    manifest_path = event_dir.parent / MANIFEST_NAME\n+    try:\n+        if not manifest_path.exists():\n+            return\n+        manifest = json.loads(manifest_path.read_text())\n+        utility = manifest.get(\"utility\", {})\n+        events_util = utility.get(\"events\", {})\n+        if not events_util:\n+            return\n+\n+        # Check which event IDs still have files\n+        existing_ids = {f.stem for f in event_dir.glob(\"evt_*.json\")}\n+        pruned = {eid: data for eid, data in events_util.items() if eid in existing_ids}\n+\n+        if len(pruned) < len(events_util):\n+            utility[\"events\"] = pruned\n+            manifest[\"utility\"] = utility\n+            atomic_write_json(manifest_path, manifest)\n+            log_debug(\n+                f\"Pruned {len(events_util) - len(pruned)} stale utility entries\",\n+                hook_name=\"memory\",\n+            )\n+    except (json.JSONDecodeError, IOError, OSError):\n+        pass\ndiff --git a/config/hooks/_sv_templates.py b/config/hooks/_sv_templates.py\nindex a6b4d29..f93b077 100644\n--- a/config/hooks/_sv_templates.py\n+++ b/config/hooks/_sv_templates.py\n@@ -34,7 +34,8 @@ GO_CHECKPOINT_SCHEMA_TEMPLATE = \"\"\"{version_note}\n     \"what_was_done\": \"...\",                  // >20 chars - what you actually did\n     \"what_remains\": \"none\",                  // Must be empty to allow stop\n     \"key_insight\": \"...\",                    // >30 chars: reusable lesson for FUTURE sessions. NOT what you did \u2014 what you LEARNED.\n-    \"search_terms\": []                       // 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"search_terms\": [],                      // 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"memory_that_helped\": []                 // Event IDs from <m> tags that helped this session (empty if none)\n   }}\n }}\"\"\"\n \n@@ -55,7 +56,8 @@ CHECKPOINT_SCHEMA_TEMPLATE = \"\"\"{version_note}\n     \"what_was_done\": \"...\",                 // Honest summary of work completed\n     \"what_remains\": \"none\",                 // Must be empty to allow stop\n     \"key_insight\": \"...\",                   // REQUIRED >30 chars: reusable lesson for FUTURE sessions. NOT what you did \u2014 what you LEARNED.\n-    \"search_terms\": []                      // REQUIRED 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"search_terms\": [],                     // REQUIRED 2-7 concept keywords for memory retrieval. Tool names, error types, patterns. NOT file paths.\n+    \"memory_that_helped\": []              \n\n... [truncated - diff too long]\n\nINSTRUCTIONS:\n- Only update docs that are actually affected by this change\n- Keep updates concise and accurate\n- Don't add unnecessary documentation\n- If the change is purely code (no architectural/API changes), you may skip doc updates\n- Focus on: API changes, new features, architectural decisions, configuration changes\n\nUse the /heavy skill if you need multiple perspectives on what to document.\n"
}