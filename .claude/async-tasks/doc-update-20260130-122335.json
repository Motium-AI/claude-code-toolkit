{
  "type": "doc-update",
  "created_at": "2026-01-30T12:23:35.426380+00:00",
  "status": "pending",
  "commit_message": "feat(hooks): consolidate autonomous mode to /repair and /forge\n\n- Add is_repair_active() as semantic alias for is_appfix_active()\n- Reorganize SKILL_TRIGGERS with /repair as primary debugging skill\n- Map repair -> appfix for state file (backwards compatibility)\n- Update get_autonomous_state() to return 'repair' instead of 'appfix'\n- Update plan-mode-enforcer terminology\n- Update documentation to recommend /repair as entry point\n- /appfix and /mobileappfix remain functional as internal skills\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>",
  "diff_content": "commit 7f83dec8b17c8284bc5afb4737a7727897a6b8d6\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Fri Jan 30 13:23:35 2026 +0100\n\n    feat(hooks): consolidate autonomous mode to /repair and /forge\n    \n    - Add is_repair_active() as semantic alias for is_appfix_active()\n    - Reorganize SKILL_TRIGGERS with /repair as primary debugging skill\n    - Map repair -> appfix for state file (backwards compatibility)\n    - Update get_autonomous_state() to return 'repair' instead of 'appfix'\n    - Update plan-mode-enforcer terminology\n    - Update documentation to recommend /repair as entry point\n    - /appfix and /mobileappfix remain functional as internal skills\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_common.py                 | 90 +++++++++++++++++++++------------\n config/hooks/_sv_validators.py          | 40 +++++++++++++++\n config/hooks/plan-mode-enforcer.py      |  6 +--\n config/hooks/skill-state-initializer.py | 58 +++++++++++++--------\n config/skills/appfix/SKILL.md           |  6 ++-\n config/skills/mobileappfix/SKILL.md     |  8 ++-\n docs/index.md                           | 32 ++++++------\n 7 files changed, 168 insertions(+), 72 deletions(-)\n\ndiff --git a/config/hooks/_common.py b/config/hooks/_common.py\nindex 4605f5a..4256a8f 100755\n--- a/config/hooks/_common.py\n+++ b/config/hooks/_common.py\n@@ -272,9 +272,30 @@ def _is_cwd_under_origin(cwd: str, user_state: dict, session_id: str = \"\") -> bo\n         return False\n \n \n+def is_repair_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if repair mode is active (unified debugging - web or mobile).\n+\n+    This is the PRIMARY function to check for debugging mode.\n+    Internally uses appfix-state.json for backwards compatibility.\n+\n+    For web vs mobile distinction, use is_mobileappfix_active().\n+\n+    Args:\n+        cwd: Current working directory path\n+        session_id: Current session ID (optional, for cross-directory trust)\n+\n+    Returns:\n+        True if repair mode is active (web OR mobile), False otherwise\n+    \"\"\"\n+    return is_appfix_active(cwd, session_id)\n+\n+\n def is_appfix_active(cwd: str, session_id: str = \"\") -> bool:\n     \"\"\"Check if appfix mode is active via non-expired state file or env var.\n \n+    NOTE: Prefer using is_repair_active() for new code. This function exists\n+    for backwards compatibility.\n+\n     Loads the state file and checks TTL expiry. Expired state files are\n     treated as inactive (cleaned up at next SessionStart).\n \n@@ -340,8 +361,8 @@ def is_mobileappfix_active(cwd: str, session_id: str = \"\") -> bool:\n     return False\n \n \n-def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if godo mode is active via non-expired state file or env var.\n+def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if forge mode is active via non-expired state file or env var.\n \n     Loads the state file and checks TTL expiry. Expired state files are\n     treated as inactive (cleaned up at next SessionStart).\n@@ -351,15 +372,15 @@ def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if godo mode is active and not expired, False otherwise\n+        True if forge mode is active and not expired, False otherwise\n     \"\"\"\n     # Check project-level state with TTL\n-    state = load_state_file(cwd, \"godo-state.json\")\n+    state = load_state_file(cwd, \"forge-state.json\")\n     if state and not is_state_expired(state):\n         return True\n \n     # Check user-level state with TTL and origin/session check\n-    user_state_path = Path.home() / \".claude\" / \"godo-state.json\"\n+    user_state_path = Path.home() / \".claude\" / \"forge-state.json\"\n     if user_state_path.exists():\n         try:\n             user_state = json.loads(user_state_path.read_text())\n@@ -369,25 +390,32 @@ def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n             pass\n \n     # Fallback: Check environment variable (no TTL for env vars)\n-    if os.environ.get(\"GODO_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n+    if os.environ.get(\"FORGE_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n         return True\n \n     return False\n \n \n+# Alias for backward compatibility\n+def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Deprecated: Use is_forge_active() instead.\"\"\"\n+    return is_forge_active(cwd, session_id)\n+\n+\n def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if any autonomous execution mode is active (godo or appfix).\n+    \"\"\"Check if any autonomous execution mode is active (forge or repair).\n \n     This is the unified check for enabling auto-approval hooks.\n+    Recognizes both /forge and /repair (/appfix, /mobileappfix) modes.\n \n     Args:\n         cwd: Current working directory path\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if godo OR appfix mode is active, False otherwise\n+        True if forge OR repair mode is active, False otherwise\n     \"\"\"\n-    return is_godo_active(cwd, session_id) or is_appfix_active(cwd, session_id)\n+    return is_forge_active(cwd, session_id) or is_repair_active(cwd, session_id)\n \n \n def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n@@ -402,7 +430,7 @@ def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n \n     Args:\n         cwd: Current working directory path\n-        filename: Name of the state file (e.g., 'godo-state.json')\n+        filename: Name of the state file (e.g., 'forge-state.json')\n \n     Returns:\n         Path to state file if found, None otherwise\n@@ -432,7 +460,7 @@ def load_state_file(cwd: str, filename: str) -> dict | None:\n \n     Args:\n         cwd: Current working directory path\n-        filename: Name of the state file (e.g., 'godo-state.json')\n+        filename: Name of the state file (e.g., 'forge-state.json')\n \n     Returns:\n         Parsed JSON contents as dict if found, None otherwise\n@@ -453,7 +481,7 @@ def update_state_file(cwd: str, filename: str, updates: dict) -> bool:\n \n     Args:\n         cwd: Current working directory path\n-        filename: Name of the state file (e.g., 'godo-state.json')\n+        filename: Name of the state file (e.g., 'forge-state.json')\n         updates: Dictionary of key-value pairs to merge into state\n \n     Returns:\n@@ -478,7 +506,7 @@ def update_state_file(cwd: str, filename: str, updates: dict) -> bool:\n def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, str | None]:\n     \"\"\"Get the autonomous mode state file and its type, filtering expired.\n \n-    Checks for godo-state.json first, then appfix-state.json.\n+    Checks for forge-state.json first, then appfix-state.json (used by /repair).\n     Checks both project-level AND user-level state files.\n     Returns None for expired state files.\n \n@@ -487,27 +515,27 @@ def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, s\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        Tuple of (state_dict, state_type) where state_type is 'godo' or 'appfix'\n+        Tuple of (state_dict, state_type) where state_type is 'forge' or 'repair'\n         Returns (None, None) if no state file found or all expired\n     \"\"\"\n-    # Check project-level godo state\n-    godo_state = load_state_file(cwd, \"godo-state.json\")\n-    if godo_state and not is_state_expired(godo_state):\n-        return godo_state, \"godo\"\n+    # Check project-level forge state\n+    forge_state = load_state_file(cwd, \"forge-state.json\")\n+    if forge_state and not is_state_expired(forge_state):\n+        return forge_state, \"forge\"\n \n-    # Check project-level appfix state\n+    # Check project-level appfix state (used by /repair)\n     appfix_state = load_state_file(cwd, \"appfix-state.json\")\n     if appfix_state and not is_state_expired(appfix_state):\n-   \n\n... [truncated - diff too long]",
  "existing_docs": [
    "docs/architecture.md",
    "docs/index.md",
    "docs/philosophy.md",
    "README.md",
    ".claude/MEMORIES.md"
  ],
  "instructions": "\nDOCUMENTATION UPDATE TASK\n\nA commit was just made in an appfix/godo session. Your job is to:\n\n1. Analyze the diff to understand what changed\n2. Determine which documentation files need updating\n3. Update the relevant docs to reflect the changes\n\nCOMMIT MESSAGE:\nfeat(hooks): consolidate autonomous mode to /repair and /forge\n\n- Add is_repair_active() as semantic alias for is_appfix_active()\n- Reorganize SKILL_TRIGGERS with /repair as primary debugging skill\n- Map repair -> appfix for state file (backwards compatibility)\n- Update get_autonomous_state() to return 'repair' instead of 'appfix'\n- Update plan-mode-enforcer terminology\n- Update documentation to recommend /repair as entry point\n- /appfix and /mobileappfix remain functional as internal skills\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\nEXISTING DOCUMENTATION FILES:\n- docs/architecture.md\n- docs/index.md\n- docs/philosophy.md\n- README.md\n- .claude/MEMORIES.md\n\nDIFF CONTENT:\ncommit 7f83dec8b17c8284bc5afb4737a7727897a6b8d6\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Fri Jan 30 13:23:35 2026 +0100\n\n    feat(hooks): consolidate autonomous mode to /repair and /forge\n    \n    - Add is_repair_active() as semantic alias for is_appfix_active()\n    - Reorganize SKILL_TRIGGERS with /repair as primary debugging skill\n    - Map repair -> appfix for state file (backwards compatibility)\n    - Update get_autonomous_state() to return 'repair' instead of 'appfix'\n    - Update plan-mode-enforcer terminology\n    - Update documentation to recommend /repair as entry point\n    - /appfix and /mobileappfix remain functional as internal skills\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_common.py                 | 90 +++++++++++++++++++++------------\n config/hooks/_sv_validators.py          | 40 +++++++++++++++\n config/hooks/plan-mode-enforcer.py      |  6 +--\n config/hooks/skill-state-initializer.py | 58 +++++++++++++--------\n config/skills/appfix/SKILL.md           |  6 ++-\n config/skills/mobileappfix/SKILL.md     |  8 ++-\n docs/index.md                           | 32 ++++++------\n 7 files changed, 168 insertions(+), 72 deletions(-)\n\ndiff --git a/config/hooks/_common.py b/config/hooks/_common.py\nindex 4605f5a..4256a8f 100755\n--- a/config/hooks/_common.py\n+++ b/config/hooks/_common.py\n@@ -272,9 +272,30 @@ def _is_cwd_under_origin(cwd: str, user_state: dict, session_id: str = \"\") -> bo\n         return False\n \n \n+def is_repair_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if repair mode is active (unified debugging - web or mobile).\n+\n+    This is the PRIMARY function to check for debugging mode.\n+    Internally uses appfix-state.json for backwards compatibility.\n+\n+    For web vs mobile distinction, use is_mobileappfix_active().\n+\n+    Args:\n+        cwd: Current working directory path\n+        session_id: Current session ID (optional, for cross-directory trust)\n+\n+    Returns:\n+        True if repair mode is active (web OR mobile), False otherwise\n+    \"\"\"\n+    return is_appfix_active(cwd, session_id)\n+\n+\n def is_appfix_active(cwd: str, session_id: str = \"\") -> bool:\n     \"\"\"Check if appfix mode is active via non-expired state file or env var.\n \n+    NOTE: Prefer using is_repair_active() for new code. This function exists\n+    for backwards compatibility.\n+\n     Loads the state file and checks TTL expiry. Expired state files are\n     treated as inactive (cleaned up at next SessionStart).\n \n@@ -340,8 +361,8 @@ def is_mobileappfix_active(cwd: str, session_id: str = \"\") -> bool:\n     return False\n \n \n-def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if godo mode is active via non-expired state file or env var.\n+def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if forge mode is active via non-expired state file or env var.\n \n     Loads the state file and checks TTL expiry. Expired state files are\n     treated as inactive (cleaned up at next SessionStart).\n@@ -351,15 +372,15 @@ def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if godo mode is active and not expired, False otherwise\n+        True if forge mode is active and not expired, False otherwise\n     \"\"\"\n     # Check project-level state with TTL\n-    state = load_state_file(cwd, \"godo-state.json\")\n+    state = load_state_file(cwd, \"forge-state.json\")\n     if state and not is_state_expired(state):\n         return True\n \n     # Check user-level state with TTL and origin/session check\n-    user_state_path = Path.home() / \".claude\" / \"godo-state.json\"\n+    user_state_path = Path.home() / \".claude\" / \"forge-state.json\"\n     if user_state_path.exists():\n         try:\n             user_state = json.loads(user_state_path.read_text())\n@@ -369,25 +390,32 @@ def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n             pass\n \n     # Fallback: Check environment variable (no TTL for env vars)\n-    if os.environ.get(\"GODO_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n+    if os.environ.get(\"FORGE_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n         return True\n \n     return False\n \n \n+# Alias for backward compatibility\n+def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Deprecated: Use is_forge_active() instead.\"\"\"\n+    return is_forge_active(cwd, session_id)\n+\n+\n def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if any autonomous execution mode is active (godo or appfix).\n+    \"\"\"Check if any autonomous execution mode is active (forge or repair).\n \n     This is the unified check for enabling auto-approval hooks.\n+    Recognizes both /forge and /repair (/appfix, /mobileappfix) modes.\n \n     Args:\n         cwd: Current working directory path\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if godo OR appfix mode is active, False otherwise\n+        True if forge OR repair mode is active, False otherwise\n     \"\"\"\n-    return is_godo_active(cwd, session_id) or is_appfix_active(cwd, session_id)\n+    return is_forge_active(cwd, session_id) or is_repair_active(cwd, session_id)\n \n \n def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n@@ -402,7 +430,7 @@ def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n \n     Args:\n         cwd: Current working directory path\n-        filename: Name of the state file (e.g., 'godo-state.json')\n+        filename: Name of the state file (e.g., 'forge-state.json')\n \n     Returns:\n         Path to state file if found, None otherwise\n@@ -432,7 +460,7 @@ def load_state_file(cwd: str, filename: str) -> dict | None:\n \n     Args:\n         cwd: Current working directory path\n-        filename: Name of the state file (e.g., 'godo-state.json')\n+        filename: Name of the state file (e.g., 'forge-state.json')\n \n     Returns:\n         Parsed JSON contents as dict if found, None otherwise\n@@ -453,7 +481,7 @@ def update_state_file(cwd: str, filename: str, updates: dict) -> bool:\n \n     Args:\n         cwd: Current working directory path\n-        filename: Name of the state file (e.g., 'godo-state.json')\n+        filename: Name of the state file (e.g., 'forge-state.json')\n         updates: Dictionary of key-value pairs to merge into state\n \n     Returns:\n@@ -478,7 +506,7 @@ def update_state_file(cwd: str, filename: str, updates: dict) -> bool:\n def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, str | None]:\n     \"\"\"Get the autonomous mode state file and its type, filtering expired.\n \n-    Checks for godo-state.json first, then appfix-state.json.\n+    Checks for forge-state.json first, then appfix-state.json (used by /repair).\n     Checks both project-level AND user-level state files.\n     Returns None for expired state files.\n \n@@ -487,27 +515,27 @@ def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, s\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        Tuple of (state_dict, state_type) where state_type is 'godo' or 'appfix'\n+        Tuple of (state_dict, state_type) where state_type is 'forge' or 'repair'\n         Returns (None, None) if no state file found or all expired\n     \"\"\"\n-    # Check project-level godo state\n-    godo_state = load_state_file(cwd, \"godo-state.json\")\n-    if godo_state and not is_state_expired(godo_state):\n-        return godo_state, \"godo\"\n+    # Check project-level forge state\n+    forge_state = load_state_file(cwd, \"forge-state.json\")\n+    if forge_state and not is_state_expired(forge_state):\n+        return forge_state, \"forge\"\n \n-    # Check project-level appfix state\n+    # Check project-level appfix state (used by /repair)\n     appfix_state = load_state_file(cwd, \"appfix-state.json\")\n     if appfix_state and not is_state_expired(appfix_state):\n-   \n\n... [truncated - diff too long]\n\nINSTRUCTIONS:\n- Only update docs that are actually affected by this change\n- Keep updates concise and accurate\n- Don't add unnecessary documentation\n- If the change is purely code (no architectural/API changes), you may skip doc updates\n- Focus on: API changes, new features, architectural decisions, configuration changes\n\nUse the /heavy skill if you need multiple perspectives on what to document.\n"
}