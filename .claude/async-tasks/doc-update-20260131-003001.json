{
  "type": "doc-update",
  "created_at": "2026-01-31T00:30:01.962828+00:00",
  "status": "pending",
  "commit_message": "feat(skill): add /go for fast autonomous execution\n\n/go is a lightweight, speed-optimized version of /build that:\n- Skips the mandatory 4-agent Lite Heavy planning phase\n- Uses ReAct-style direct execution\n- Has simplified 2-field checkpoint (is_job_complete, what_remains)\n- Achieves 8-10x speedup over /build for quick tasks\n\nKey implementation:\n- Creates go-state.json with plan_mode_completed=true from start\n- Bypasses plan-mode-enforcer and lite-heavy-enforcer hooks\n- Simplified validation in stop-validator (core completion only)\n- Auto-approval and session persistence remain active\n\nUse /go for: known fixes, single-file changes, <100 LOC diffs\nUse /build for: complex tasks, multi-file refactors, exploration\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>",
  "diff_content": "commit e3700a1112de27b5a0565b9ce060bca167b7aa3f\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Sat Jan 31 01:30:01 2026 +0100\n\n    feat(skill): add /go for fast autonomous execution\n    \n    /go is a lightweight, speed-optimized version of /build that:\n    - Skips the mandatory 4-agent Lite Heavy planning phase\n    - Uses ReAct-style direct execution\n    - Has simplified 2-field checkpoint (is_job_complete, what_remains)\n    - Achieves 8-10x speedup over /build for quick tasks\n    \n    Key implementation:\n    - Creates go-state.json with plan_mode_completed=true from start\n    - Bypasses plan-mode-enforcer and lite-heavy-enforcer hooks\n    - Simplified validation in stop-validator (core completion only)\n    - Auto-approval and session persistence remain active\n    \n    Use /go for: known fixes, single-file changes, <100 LOC diffs\n    Use /build for: complex tasks, multi-file refactors, exploration\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_state.py                  |  53 ++++++++++++---\n config/hooks/_sv_validators.py          |  11 +++\n config/hooks/skill-state-initializer.py |  14 +++-\n config/skills/go/SKILL.md               | 114 ++++++++++++++++++++++++++++++++\n docs/index.md                           |  19 ++++--\n 5 files changed, 197 insertions(+), 14 deletions(-)\n\ndiff --git a/config/hooks/_state.py b/config/hooks/_state.py\nindex 4460a08..a40531e 100644\n--- a/config/hooks/_state.py\n+++ b/config/hooks/_state.py\n@@ -250,13 +250,39 @@ def is_episode_active(cwd: str, session_id: str = \"\") -> bool:\n     return False\n \n \n+def is_go_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if /go fast execution mode is active via state file or env var.\n+\n+    /go is a lightweight, speed-optimized version of /build that skips\n+    the mandatory Lite Heavy planning phase.\n+    \"\"\"\n+    state = load_state_file(cwd, \"go-state.json\")\n+    if state and not is_state_expired(state):\n+        return True\n+\n+    user_state_path = Path.home() / \".claude\" / \"go-state.json\"\n+    if user_state_path.exists():\n+        try:\n+            user_state = json.loads(user_state_path.read_text())\n+            if not is_state_expired(user_state) and _is_cwd_under_origin(cwd, user_state, session_id):\n+                return True\n+        except (json.JSONDecodeError, IOError):\n+            pass\n+\n+    if os.environ.get(\"GO_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n+        return True\n+\n+    return False\n+\n+\n def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if any autonomous execution mode is active (build, repair, burndown, or episode).\n+    \"\"\"Check if any autonomous execution mode is active (go, build, repair, burndown, or episode).\n \n     This is the unified check for enabling auto-approval hooks.\n     \"\"\"\n     return (\n-        is_build_active(cwd, session_id)\n+        is_go_active(cwd, session_id)\n+        or is_build_active(cwd, session_id)\n         or is_repair_active(cwd, session_id)\n         or is_burndown_active(cwd, session_id)\n         or is_episode_active(cwd, session_id)\n@@ -266,13 +292,18 @@ def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, str | None]:\n     \"\"\"Get the autonomous mode state file and its type, filtering expired.\n \n-    Checks build-state first, then appfix-state (repair), then burndown-state.\n+    Checks go-state first (fast mode), then build-state, appfix-state (repair), burndown-state, episode-state.\n     Checks both project-level AND user-level state files.\n \n     Returns:\n-        Tuple of (state_dict, state_type) where state_type is 'build', 'repair', or 'burndown'\n+        Tuple of (state_dict, state_type) where state_type is 'go', 'build', 'repair', 'burndown', or 'episode'\n         Returns (None, None) if no state file found or all expired\n     \"\"\"\n+    # Check /go first (takes precedence as fast mode)\n+    go_state = load_state_file(cwd, \"go-state.json\")\n+    if go_state and not is_state_expired(go_state):\n+        return go_state, \"go\"\n+\n     for build_filename in (\"build-state.json\", \"forge-state.json\"):\n         build_state = load_state_file(cwd, build_filename)\n         if build_state and not is_state_expired(build_state):\n@@ -291,6 +322,7 @@ def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, s\n         return episode_state, \"episode\"\n \n     for filename, state_type in [\n+        (\"go-state.json\", \"go\"),\n         (\"build-state.json\", \"build\"),\n         (\"forge-state.json\", \"build\"),\n         (\"appfix-state.json\", \"repair\"),\n@@ -322,7 +354,7 @@ def cleanup_autonomous_state(cwd: str) -> list[str]:\n     2. ALL .claude/ directories walking UP from cwd\n     \"\"\"\n     deleted = []\n-    state_files = [\"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n+    state_files = [\"go-state.json\", \"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n \n     # 1. Clean user-level state\n     user_claude_dir = Path.home() / \".claude\"\n@@ -412,7 +444,7 @@ def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n     Called at SessionStart to clean up stale state from previous sessions.\n     \"\"\"\n     deleted = []\n-    state_files = [\"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n+    state_files = [\"go-state.json\", \"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n \n     def _should_clean(state_path: Path) -> bool:\n         try:\n@@ -488,14 +520,19 @@ def reset_state_for_next_task(cwd: str) -> bool:\n \n     Increments iteration, resets plan_mode_completed, updates last_activity_at,\n     clears per-task fields. Does NOT delete the state file (sticky session behavior).\n+\n+    NOTE: For /go mode, plan_mode_completed is NOT reset (it stays true)\n+    because /go skips the planning phase by design.\n     \"\"\"\n-    for filename in (\"build-state.json\", \"forge-state.json\", \"appfix-state.json\", \"burndown-state.json\", \"episode-state.json\"):\n+    for filename in (\"go-state.json\", \"build-state.json\", \"forge-state.json\", \"appfix-state.json\", \"burndown-state.json\", \"episode-state.json\"):\n         state_path = _find_state_file_path(cwd, filename)\n         if state_path:\n             try:\n                 state = json.loads(state_path.read_text())\n                 state[\"iteration\"] = state.get(\"iteration\", 1) + 1\n-                state[\"plan_mode_completed\"] = False\n+                # /go mode keeps plan_mode_completed=True (skips planning by design)\n+                if filename != \"go-state.json\":\n+                    state[\"plan_mode_completed\"] = False\n                 state[\"verification_evidence\"] = None\n                 state[\"services\"] = {}\n                 state[\"last_activity_at\"] = datetime.now(timezone.utc).strftime(\ndiff --git a/config/hooks/_sv_validators.py b/config/hooks/_sv_validators.py\nindex 0ca30d4..09c8715 100644\n--- a/config/hooks/_sv_validators.py\n+++ b/config/hooks/_sv_validators.py\n@@ -26,6 +26,7 @@ from _state import (\n     is_appfix_active,\n     is_mobileappfix_active,\n     is_build_active,\n+    is_go_active,\n     is_autonomous_mode_active,\n )\n \n@@ -786,11 +787,21 @@ def validate_checkpoint(\n     \"\"\"Validate checkpoint booleans deterministically.\n \n     Orchestrates all sub-validators and auto-resets stale fields.\n+\n+    SPECIAL CASE: /go mode uses simplified validation (only core completion checks).\n+    This enables fast execution without heavyweight verification requirements.\n+\n     Returns (is_valid, list_of_failures)\n     \"\"\"\n     failures = []\n     report = checkpoint.get(\"self_report\", {})\n     reflection = checkpoint.get(\"reflection\", {})\n+\n+    # FAST PATH: /go mode uses simplified validation\n+    # Only checks is_job_complete and what_remains\n+    i\n\n... [truncated - diff too long]",
  "existing_docs": [
    "docs/architecture.md",
    "docs/analysis-persistent-memory-for-harnesses.md",
    "docs/index.md",
    "docs/memory-integration-analysis.md",
    "docs/philosophy.md",
    "docs/audiobook-the-amnesiac-architect.md",
    "README.md",
    ".claude/MEMORIES.md"
  ],
  "instructions": "\nDOCUMENTATION UPDATE TASK\n\nA commit was just made in an repair/build session. Your job is to:\n\n1. Analyze the diff to understand what changed\n2. Determine which documentation files need updating\n3. Update the relevant docs to reflect the changes\n\nCOMMIT MESSAGE:\nfeat(skill): add /go for fast autonomous execution\n\n/go is a lightweight, speed-optimized version of /build that:\n- Skips the mandatory 4-agent Lite Heavy planning phase\n- Uses ReAct-style direct execution\n- Has simplified 2-field checkpoint (is_job_complete, what_remains)\n- Achieves 8-10x speedup over /build for quick tasks\n\nKey implementation:\n- Creates go-state.json with plan_mode_completed=true from start\n- Bypasses plan-mode-enforcer and lite-heavy-enforcer hooks\n- Simplified validation in stop-validator (core completion only)\n- Auto-approval and session persistence remain active\n\nUse /go for: known fixes, single-file changes, <100 LOC diffs\nUse /build for: complex tasks, multi-file refactors, exploration\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\nEXISTING DOCUMENTATION FILES:\n- docs/architecture.md\n- docs/analysis-persistent-memory-for-harnesses.md\n- docs/index.md\n- docs/memory-integration-analysis.md\n- docs/philosophy.md\n- docs/audiobook-the-amnesiac-architect.md\n- README.md\n- .claude/MEMORIES.md\n\nDIFF CONTENT:\ncommit e3700a1112de27b5a0565b9ce060bca167b7aa3f\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Sat Jan 31 01:30:01 2026 +0100\n\n    feat(skill): add /go for fast autonomous execution\n    \n    /go is a lightweight, speed-optimized version of /build that:\n    - Skips the mandatory 4-agent Lite Heavy planning phase\n    - Uses ReAct-style direct execution\n    - Has simplified 2-field checkpoint (is_job_complete, what_remains)\n    - Achieves 8-10x speedup over /build for quick tasks\n    \n    Key implementation:\n    - Creates go-state.json with plan_mode_completed=true from start\n    - Bypasses plan-mode-enforcer and lite-heavy-enforcer hooks\n    - Simplified validation in stop-validator (core completion only)\n    - Auto-approval and session persistence remain active\n    \n    Use /go for: known fixes, single-file changes, <100 LOC diffs\n    Use /build for: complex tasks, multi-file refactors, exploration\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_state.py                  |  53 ++++++++++++---\n config/hooks/_sv_validators.py          |  11 +++\n config/hooks/skill-state-initializer.py |  14 +++-\n config/skills/go/SKILL.md               | 114 ++++++++++++++++++++++++++++++++\n docs/index.md                           |  19 ++++--\n 5 files changed, 197 insertions(+), 14 deletions(-)\n\ndiff --git a/config/hooks/_state.py b/config/hooks/_state.py\nindex 4460a08..a40531e 100644\n--- a/config/hooks/_state.py\n+++ b/config/hooks/_state.py\n@@ -250,13 +250,39 @@ def is_episode_active(cwd: str, session_id: str = \"\") -> bool:\n     return False\n \n \n+def is_go_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if /go fast execution mode is active via state file or env var.\n+\n+    /go is a lightweight, speed-optimized version of /build that skips\n+    the mandatory Lite Heavy planning phase.\n+    \"\"\"\n+    state = load_state_file(cwd, \"go-state.json\")\n+    if state and not is_state_expired(state):\n+        return True\n+\n+    user_state_path = Path.home() / \".claude\" / \"go-state.json\"\n+    if user_state_path.exists():\n+        try:\n+            user_state = json.loads(user_state_path.read_text())\n+            if not is_state_expired(user_state) and _is_cwd_under_origin(cwd, user_state, session_id):\n+                return True\n+        except (json.JSONDecodeError, IOError):\n+            pass\n+\n+    if os.environ.get(\"GO_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n+        return True\n+\n+    return False\n+\n+\n def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if any autonomous execution mode is active (build, repair, burndown, or episode).\n+    \"\"\"Check if any autonomous execution mode is active (go, build, repair, burndown, or episode).\n \n     This is the unified check for enabling auto-approval hooks.\n     \"\"\"\n     return (\n-        is_build_active(cwd, session_id)\n+        is_go_active(cwd, session_id)\n+        or is_build_active(cwd, session_id)\n         or is_repair_active(cwd, session_id)\n         or is_burndown_active(cwd, session_id)\n         or is_episode_active(cwd, session_id)\n@@ -266,13 +292,18 @@ def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, str | None]:\n     \"\"\"Get the autonomous mode state file and its type, filtering expired.\n \n-    Checks build-state first, then appfix-state (repair), then burndown-state.\n+    Checks go-state first (fast mode), then build-state, appfix-state (repair), burndown-state, episode-state.\n     Checks both project-level AND user-level state files.\n \n     Returns:\n-        Tuple of (state_dict, state_type) where state_type is 'build', 'repair', or 'burndown'\n+        Tuple of (state_dict, state_type) where state_type is 'go', 'build', 'repair', 'burndown', or 'episode'\n         Returns (None, None) if no state file found or all expired\n     \"\"\"\n+    # Check /go first (takes precedence as fast mode)\n+    go_state = load_state_file(cwd, \"go-state.json\")\n+    if go_state and not is_state_expired(go_state):\n+        return go_state, \"go\"\n+\n     for build_filename in (\"build-state.json\", \"forge-state.json\"):\n         build_state = load_state_file(cwd, build_filename)\n         if build_state and not is_state_expired(build_state):\n@@ -291,6 +322,7 @@ def get_autonomous_state(cwd: str, session_id: str = \"\") -> tuple[dict | None, s\n         return episode_state, \"episode\"\n \n     for filename, state_type in [\n+        (\"go-state.json\", \"go\"),\n         (\"build-state.json\", \"build\"),\n         (\"forge-state.json\", \"build\"),\n         (\"appfix-state.json\", \"repair\"),\n@@ -322,7 +354,7 @@ def cleanup_autonomous_state(cwd: str) -> list[str]:\n     2. ALL .claude/ directories walking UP from cwd\n     \"\"\"\n     deleted = []\n-    state_files = [\"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n+    state_files = [\"go-state.json\", \"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n \n     # 1. Clean user-level state\n     user_claude_dir = Path.home() / \".claude\"\n@@ -412,7 +444,7 @@ def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n     Called at SessionStart to clean up stale state from previous sessions.\n     \"\"\"\n     deleted = []\n-    state_files = [\"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n+    state_files = [\"go-state.json\", \"appfix-state.json\", \"build-state.json\", \"forge-state.json\", \"burndown-state.json\", \"episode-state.json\"]\n \n     def _should_clean(state_path: Path) -> bool:\n         try:\n@@ -488,14 +520,19 @@ def reset_state_for_next_task(cwd: str) -> bool:\n \n     Increments iteration, resets plan_mode_completed, updates last_activity_at,\n     clears per-task fields. Does NOT delete the state file (sticky session behavior).\n+\n+    NOTE: For /go mode, plan_mode_completed is NOT reset (it stays true)\n+    because /go skips the planning phase by design.\n     \"\"\"\n-    for filename in (\"build-state.json\", \"forge-state.json\", \"appfix-state.json\", \"burndown-state.json\", \"episode-state.json\"):\n+    for filename in (\"go-state.json\", \"build-state.json\", \"forge-state.json\", \"appfix-state.json\", \"burndown-state.json\", \"episode-state.json\"):\n         state_path = _find_state_file_path(cwd, filename)\n         if state_path:\n             try:\n                 state = json.loads(state_path.read_text())\n                 state[\"iteration\"] = state.get(\"iteration\", 1) + 1\n-                state[\"plan_mode_completed\"] = False\n+                # /go mode keeps plan_mode_completed=True (skips planning by design)\n+                if filename != \"go-state.json\":\n+                    state[\"plan_mode_completed\"] = False\n                 state[\"verification_evidence\"] = None\n                 state[\"services\"] = {}\n                 state[\"last_activity_at\"] = datetime.now(timezone.utc).strftime(\ndiff --git a/config/hooks/_sv_validators.py b/config/hooks/_sv_validators.py\nindex 0ca30d4..09c8715 100644\n--- a/config/hooks/_sv_validators.py\n+++ b/config/hooks/_sv_validators.py\n@@ -26,6 +26,7 @@ from _state import (\n     is_appfix_active,\n     is_mobileappfix_active,\n     is_build_active,\n+    is_go_active,\n     is_autonomous_mode_active,\n )\n \n@@ -786,11 +787,21 @@ def validate_checkpoint(\n     \"\"\"Validate checkpoint booleans deterministically.\n \n     Orchestrates all sub-validators and auto-resets stale fields.\n+\n+    SPECIAL CASE: /go mode uses simplified validation (only core completion checks).\n+    This enables fast execution without heavyweight verification requirements.\n+\n     Returns (is_valid, list_of_failures)\n     \"\"\"\n     failures = []\n     report = checkpoint.get(\"self_report\", {})\n     reflection = checkpoint.get(\"reflection\", {})\n+\n+    # FAST PATH: /go mode uses simplified validation\n+    # Only checks is_job_complete and what_remains\n+    i\n\n... [truncated - diff too long]\n\nINSTRUCTIONS:\n- Only update docs that are actually affected by this change\n- Keep updates concise and accurate\n- Don't add unnecessary documentation\n- If the change is purely code (no architectural/API changes), you may skip doc updates\n- Focus on: API changes, new features, architectural decisions, configuration changes\n\nUse the /heavy skill if you need multiple perspectives on what to document.\n"
}