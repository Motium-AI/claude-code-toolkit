{
  "type": "doc-update",
  "created_at": "2026-01-30T11:28:09.972790+00:00",
  "status": "pending",
  "commit_message": "feat(hooks): add multi-session auto-approval support\n\nPreviously, running 7+ Claude Code sessions simultaneously would fail\nbecause each new session overwrote the user-level state file, breaking\nauto-approval for all other sessions.\n\nChanges:\n- skill-state-initializer: Add sessions to dict instead of overwriting\n- plan-mode-tracker: Update session entries in sessions dict\n- _common.py: Handle multi-session state cleanup and validation\n\nNew user-level state format:\n```json\n{\n  \"sessions\": {\n    \"abc123\": {\"origin_project\": \"/path/a\", \"started_at\": \"...\"},\n    \"def456\": {\"origin_project\": \"/path/b\", \"started_at\": \"...\"}\n  }\n}\n```\n\nMaintains backward compatibility with legacy single-session format.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>",
  "diff_content": "commit 26aa11d50e4e023d7eb334efd1f49408ce67ed38\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Fri Jan 30 12:28:09 2026 +0100\n\n    feat(hooks): add multi-session auto-approval support\n    \n    Previously, running 7+ Claude Code sessions simultaneously would fail\n    because each new session overwrote the user-level state file, breaking\n    auto-approval for all other sessions.\n    \n    Changes:\n    - skill-state-initializer: Add sessions to dict instead of overwriting\n    - plan-mode-tracker: Update session entries in sessions dict\n    - _common.py: Handle multi-session state cleanup and validation\n    \n    New user-level state format:\n    ```json\n    {\n      \"sessions\": {\n        \"abc123\": {\"origin_project\": \"/path/a\", \"started_at\": \"...\"},\n        \"def456\": {\"origin_project\": \"/path/b\", \"started_at\": \"...\"}\n      }\n    }\n    ```\n    \n    Maintains backward compatibility with legacy single-session format.\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_common.py                 | 115 +++++++++++++++++++++++++-------\n config/hooks/plan-mode-tracker.py       |  24 ++++++-\n config/hooks/skill-state-initializer.py |  72 ++++++++++++++++----\n 3 files changed, 173 insertions(+), 38 deletions(-)\n\ndiff --git a/config/hooks/_common.py b/config/hooks/_common.py\nindex adfefd8..4605f5a 100755\n--- a/config/hooks/_common.py\n+++ b/config/hooks/_common.py\n@@ -231,6 +231,9 @@ def _is_cwd_under_origin(cwd: str, user_state: dict, session_id: str = \"\") -> bo\n     trust the session regardless of directory. This allows a session to work\n     across directories (e.g., navigating to a test directory during appfix).\n \n+    MULTI-SESSION SUPPORT: User-level state may have a \"sessions\" dict that maps\n+    session_id to session info. If session_id is found in sessions, trust it.\n+\n     Args:\n         cwd: Current working directory path\n         user_state: Parsed user-level state file dict\n@@ -239,8 +242,19 @@ def _is_cwd_under_origin(cwd: str, user_state: dict, session_id: str = \"\") -> bo\n     Returns:\n         True if cwd is under origin_project (or origin_project not set), False otherwise\n     \"\"\"\n-    # Trust matching session - same session can work anywhere\n+    # MULTI-SESSION: Check if session_id exists in sessions dict\n+    # This is the new format that supports multiple parallel sessions\n+    sessions = user_state.get(\"sessions\", {})\n+    if session_id and session_id in sessions:\n+        session_info = sessions[session_id]\n+        # Check TTL for this specific session\n+        # If session is found but expired, return False immediately\n+        # (don't fall through to legacy checks)\n+        return not is_state_expired(session_info)\n+\n+    # LEGACY: Trust matching session - same session can work anywhere\n     # This enables cross-directory workflows (e.g., appfix navigating to test dirs)\n+    # Only applies if session_id was NOT found in the new sessions dict\n     if session_id and user_state.get(\"session_id\") == session_id:\n         return True\n \n@@ -678,12 +692,23 @@ def reset_state_for_next_task(cwd: str) -> bool:\n                 )\n                 state_path.write_text(json.dumps(state, indent=2))\n \n-                # Also update user-level state timestamp\n+                # Also update user-level state timestamp (both legacy and sessions dict)\n+                session_id = state.get(\"session_id\", \"\")\n                 user_state_path = Path.home() / \".claude\" / filename\n                 if user_state_path.exists():\n                     try:\n                         user_state = json.loads(user_state_path.read_text())\n+                        # Update legacy root-level fields\n                         user_state[\"last_activity_at\"] = state[\"last_activity_at\"]\n+                        user_state[\"plan_mode_completed\"] = False\n+\n+                        # Update session in sessions dict (multi-session support)\n+                        if session_id and \"sessions\" in user_state:\n+                            sessions = user_state.get(\"sessions\", {})\n+                            if session_id in sessions:\n+                                sessions[session_id][\"last_activity_at\"] = state[\"last_activity_at\"]\n+                                sessions[session_id][\"plan_mode_completed\"] = False\n+\n                         user_state_path.write_text(json.dumps(user_state, indent=2))\n                     except (json.JSONDecodeError, IOError):\n                         pass\n@@ -694,6 +719,64 @@ def reset_state_for_next_task(cwd: str) -> bool:\n     return False\n \n \n+def _cleanup_user_level_sessions(state_path: Path) -> bool:\n+    \"\"\"Clean up expired sessions from user-level state file.\n+\n+    MULTI-SESSION SUPPORT: Instead of deleting the whole file, remove\n+    individual expired sessions from the sessions dict.\n+\n+    Args:\n+        state_path: Path to the user-level state file\n+\n+    Returns:\n+        True if file was deleted (all sessions expired), False otherwise\n+    \"\"\"\n+    try:\n+        state = json.loads(state_path.read_text())\n+    except (json.JSONDecodeError, IOError):\n+        # Corrupt file - delete it\n+        try:\n+            state_path.unlink()\n+            return True\n+        except (IOError, OSError):\n+            return False\n+\n+    # Handle multi-session format\n+    sessions = state.get(\"sessions\", {})\n+    if sessions:\n+        # Remove expired sessions\n+        valid_sessions = {}\n+        for session_id, session_info in sessions.items():\n+            if not is_state_expired(session_info):\n+                valid_sessions[session_id] = session_info\n+\n+        if not valid_sessions:\n+            # All sessions expired - delete the file\n+            try:\n+                state_path.unlink()\n+                return True\n+            except (IOError, OSError):\n+                return False\n+        elif len(valid_sessions) < len(sessions):\n+            # Some sessions expired - update the file\n+            state[\"sessions\"] = valid_sessions\n+            try:\n+                state_path.write_text(json.dumps(state, indent=2))\n+            except (IOError, OSError):\n+                pass\n+        return False\n+\n+    # Legacy format (no sessions dict) - check root-level TTL\n+    if is_state_expired(state):\n+        try:\n+            state_path.unlink()\n+            return True\n+        except (IOError, OSError):\n+            return False\n+\n+    return False\n+\n+\n def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n     \"\"\"Delete state files that are expired OR belong to a different session.\n \n@@ -705,6 +788,10 @@ def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n \n     Cleans both project-level and user-level state files.\n \n+    MULTI-SESSION SUPPORT: User-level state files have a \"sessions\" dict\n+    that maps session_id to session info. Expired sessions are removed\n+    from the dict rather than deleting the whole file.\n+\n     Args:\n         cwd: Working directory to start walk-up from\n         current_session_id: Current session's ID (empty = clean only expired)\n@@ -715,21 +802,6 @@ def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n     deleted = []\n     state_files = [\"appfix-state.json\", \"godo-state.json\"]\n \n-    def _should_clean_user_level(state_path: Path) -> bool:\n-        \"\"\"Check if a user-level state file should be cleaned up.\n-\n-        User-level state is ONLY cleaned based on TTL expiration.\n-        We do NOT clean based on session_id mismatch because user-level state\n-        is meant to persist across sessions for cross-directory autonomous mode.\n-        \"\"\"\n-        try:\n-            state = json.loads(state_path.read_text())\n-        except (json.JSONDecodeError, IOError):\n-            return True  # Corrupt file = clean up\n-\n-        # Only clean if expired (TTL-based)\n-        return is_state_expired(state)\n-\n     def _should_clean_project_level(state_path: Path) -> bool:\n       \n\n... [truncated - diff too long]",
  "existing_docs": [
    "docs/architecture.md",
    "docs/index.md",
    "docs/philosophy.md",
    "README.md",
    ".claude/MEMORIES.md"
  ],
  "instructions": "\nDOCUMENTATION UPDATE TASK\n\nA commit was just made in an appfix/godo session. Your job is to:\n\n1. Analyze the diff to understand what changed\n2. Determine which documentation files need updating\n3. Update the relevant docs to reflect the changes\n\nCOMMIT MESSAGE:\nfeat(hooks): add multi-session auto-approval support\n\nPreviously, running 7+ Claude Code sessions simultaneously would fail\nbecause each new session overwrote the user-level state file, breaking\nauto-approval for all other sessions.\n\nChanges:\n- skill-state-initializer: Add sessions to dict instead of overwriting\n- plan-mode-tracker: Update session entries in sessions dict\n- _common.py: Handle multi-session state cleanup and validation\n\nNew user-level state format:\n```json\n{\n  \"sessions\": {\n    \"abc123\": {\"origin_project\": \"/path/a\", \"started_at\": \"...\"},\n    \"def456\": {\"origin_project\": \"/path/b\", \"started_at\": \"...\"}\n  }\n}\n```\n\nMaintains backward compatibility with legacy single-session format.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\nEXISTING DOCUMENTATION FILES:\n- docs/architecture.md\n- docs/index.md\n- docs/philosophy.md\n- README.md\n- .claude/MEMORIES.md\n\nDIFF CONTENT:\ncommit 26aa11d50e4e023d7eb334efd1f49408ce67ed38\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Fri Jan 30 12:28:09 2026 +0100\n\n    feat(hooks): add multi-session auto-approval support\n    \n    Previously, running 7+ Claude Code sessions simultaneously would fail\n    because each new session overwrote the user-level state file, breaking\n    auto-approval for all other sessions.\n    \n    Changes:\n    - skill-state-initializer: Add sessions to dict instead of overwriting\n    - plan-mode-tracker: Update session entries in sessions dict\n    - _common.py: Handle multi-session state cleanup and validation\n    \n    New user-level state format:\n    ```json\n    {\n      \"sessions\": {\n        \"abc123\": {\"origin_project\": \"/path/a\", \"started_at\": \"...\"},\n        \"def456\": {\"origin_project\": \"/path/b\", \"started_at\": \"...\"}\n      }\n    }\n    ```\n    \n    Maintains backward compatibility with legacy single-session format.\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_common.py                 | 115 +++++++++++++++++++++++++-------\n config/hooks/plan-mode-tracker.py       |  24 ++++++-\n config/hooks/skill-state-initializer.py |  72 ++++++++++++++++----\n 3 files changed, 173 insertions(+), 38 deletions(-)\n\ndiff --git a/config/hooks/_common.py b/config/hooks/_common.py\nindex adfefd8..4605f5a 100755\n--- a/config/hooks/_common.py\n+++ b/config/hooks/_common.py\n@@ -231,6 +231,9 @@ def _is_cwd_under_origin(cwd: str, user_state: dict, session_id: str = \"\") -> bo\n     trust the session regardless of directory. This allows a session to work\n     across directories (e.g., navigating to a test directory during appfix).\n \n+    MULTI-SESSION SUPPORT: User-level state may have a \"sessions\" dict that maps\n+    session_id to session info. If session_id is found in sessions, trust it.\n+\n     Args:\n         cwd: Current working directory path\n         user_state: Parsed user-level state file dict\n@@ -239,8 +242,19 @@ def _is_cwd_under_origin(cwd: str, user_state: dict, session_id: str = \"\") -> bo\n     Returns:\n         True if cwd is under origin_project (or origin_project not set), False otherwise\n     \"\"\"\n-    # Trust matching session - same session can work anywhere\n+    # MULTI-SESSION: Check if session_id exists in sessions dict\n+    # This is the new format that supports multiple parallel sessions\n+    sessions = user_state.get(\"sessions\", {})\n+    if session_id and session_id in sessions:\n+        session_info = sessions[session_id]\n+        # Check TTL for this specific session\n+        # If session is found but expired, return False immediately\n+        # (don't fall through to legacy checks)\n+        return not is_state_expired(session_info)\n+\n+    # LEGACY: Trust matching session - same session can work anywhere\n     # This enables cross-directory workflows (e.g., appfix navigating to test dirs)\n+    # Only applies if session_id was NOT found in the new sessions dict\n     if session_id and user_state.get(\"session_id\") == session_id:\n         return True\n \n@@ -678,12 +692,23 @@ def reset_state_for_next_task(cwd: str) -> bool:\n                 )\n                 state_path.write_text(json.dumps(state, indent=2))\n \n-                # Also update user-level state timestamp\n+                # Also update user-level state timestamp (both legacy and sessions dict)\n+                session_id = state.get(\"session_id\", \"\")\n                 user_state_path = Path.home() / \".claude\" / filename\n                 if user_state_path.exists():\n                     try:\n                         user_state = json.loads(user_state_path.read_text())\n+                        # Update legacy root-level fields\n                         user_state[\"last_activity_at\"] = state[\"last_activity_at\"]\n+                        user_state[\"plan_mode_completed\"] = False\n+\n+                        # Update session in sessions dict (multi-session support)\n+                        if session_id and \"sessions\" in user_state:\n+                            sessions = user_state.get(\"sessions\", {})\n+                            if session_id in sessions:\n+                                sessions[session_id][\"last_activity_at\"] = state[\"last_activity_at\"]\n+                                sessions[session_id][\"plan_mode_completed\"] = False\n+\n                         user_state_path.write_text(json.dumps(user_state, indent=2))\n                     except (json.JSONDecodeError, IOError):\n                         pass\n@@ -694,6 +719,64 @@ def reset_state_for_next_task(cwd: str) -> bool:\n     return False\n \n \n+def _cleanup_user_level_sessions(state_path: Path) -> bool:\n+    \"\"\"Clean up expired sessions from user-level state file.\n+\n+    MULTI-SESSION SUPPORT: Instead of deleting the whole file, remove\n+    individual expired sessions from the sessions dict.\n+\n+    Args:\n+        state_path: Path to the user-level state file\n+\n+    Returns:\n+        True if file was deleted (all sessions expired), False otherwise\n+    \"\"\"\n+    try:\n+        state = json.loads(state_path.read_text())\n+    except (json.JSONDecodeError, IOError):\n+        # Corrupt file - delete it\n+        try:\n+            state_path.unlink()\n+            return True\n+        except (IOError, OSError):\n+            return False\n+\n+    # Handle multi-session format\n+    sessions = state.get(\"sessions\", {})\n+    if sessions:\n+        # Remove expired sessions\n+        valid_sessions = {}\n+        for session_id, session_info in sessions.items():\n+            if not is_state_expired(session_info):\n+                valid_sessions[session_id] = session_info\n+\n+        if not valid_sessions:\n+            # All sessions expired - delete the file\n+            try:\n+                state_path.unlink()\n+                return True\n+            except (IOError, OSError):\n+                return False\n+        elif len(valid_sessions) < len(sessions):\n+            # Some sessions expired - update the file\n+            state[\"sessions\"] = valid_sessions\n+            try:\n+                state_path.write_text(json.dumps(state, indent=2))\n+            except (IOError, OSError):\n+                pass\n+        return False\n+\n+    # Legacy format (no sessions dict) - check root-level TTL\n+    if is_state_expired(state):\n+        try:\n+            state_path.unlink()\n+            return True\n+        except (IOError, OSError):\n+            return False\n+\n+    return False\n+\n+\n def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n     \"\"\"Delete state files that are expired OR belong to a different session.\n \n@@ -705,6 +788,10 @@ def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n \n     Cleans both project-level and user-level state files.\n \n+    MULTI-SESSION SUPPORT: User-level state files have a \"sessions\" dict\n+    that maps session_id to session info. Expired sessions are removed\n+    from the dict rather than deleting the whole file.\n+\n     Args:\n         cwd: Working directory to start walk-up from\n         current_session_id: Current session's ID (empty = clean only expired)\n@@ -715,21 +802,6 @@ def cleanup_expired_state(cwd: str, current_session_id: str = \"\") -> list[str]:\n     deleted = []\n     state_files = [\"appfix-state.json\", \"godo-state.json\"]\n \n-    def _should_clean_user_level(state_path: Path) -> bool:\n-        \"\"\"Check if a user-level state file should be cleaned up.\n-\n-        User-level state is ONLY cleaned based on TTL expiration.\n-        We do NOT clean based on session_id mismatch because user-level state\n-        is meant to persist across sessions for cross-directory autonomous mode.\n-        \"\"\"\n-        try:\n-            state = json.loads(state_path.read_text())\n-        except (json.JSONDecodeError, IOError):\n-            return True  # Corrupt file = clean up\n-\n-        # Only clean if expired (TTL-based)\n-        return is_state_expired(state)\n-\n     def _should_clean_project_level(state_path: Path) -> bool:\n       \n\n... [truncated - diff too long]\n\nINSTRUCTIONS:\n- Only update docs that are actually affected by this change\n- Keep updates concise and accurate\n- Don't add unnecessary documentation\n- If the change is purely code (no architectural/API changes), you may skip doc updates\n- Focus on: API changes, new features, architectural decisions, configuration changes\n\nUse the /heavy skill if you need multiple perspectives on what to document.\n"
}