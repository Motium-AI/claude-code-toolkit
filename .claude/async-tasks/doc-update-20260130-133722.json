{
  "type": "doc-update",
  "created_at": "2026-01-30T13:37:22.065951+00:00",
  "status": "pending",
  "commit_message": "fix(hooks): macOS _get_ancestor_pid() basename fix + plan-mode-tracker fallback\n\n- Fix _get_ancestor_pid() on macOS where ps returns full paths (/bin/zsh)\n  instead of just binary names (zsh), causing PID-scoped filenames to be\n  inconsistent across invocations\n- Add legacy forge-state.json fallback in plan-mode-tracker for build\n  state_type, so ExitPlanMode correctly updates existing forge state files\n- Update test to expect build-state (not forge-state) for /godo prompt\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>",
  "diff_content": "commit 11bee546333f04293942efc895e9f14cf81a7217\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Fri Jan 30 14:37:21 2026 +0100\n\n    fix(hooks): macOS _get_ancestor_pid() basename fix + plan-mode-tracker fallback\n    \n    - Fix _get_ancestor_pid() on macOS where ps returns full paths (/bin/zsh)\n      instead of just binary names (zsh), causing PID-scoped filenames to be\n      inconsistent across invocations\n    - Add legacy forge-state.json fallback in plan-mode-tracker for build\n      state_type, so ExitPlanMode correctly updates existing forge state files\n    - Update test to expect build-state (not forge-state) for /godo prompt\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_common.py                    | 110 ++++++++++++++++-------------\n config/hooks/plan-mode-tracker.py          |  32 +++++----\n config/hooks/tests/test_plan_mode_hooks.py |   8 +--\n 3 files changed, 84 insertions(+), 66 deletions(-)\n\ndiff --git a/config/hooks/_common.py b/config/hooks/_common.py\nindex 1bcf339..d3409e9 100755\n--- a/config/hooks/_common.py\n+++ b/config/hooks/_common.py\n@@ -90,11 +90,11 @@ def _scoped_filename(filename: str, pid: int | None = None) -> str:\n     \"\"\"Convert a state filename to its PID-scoped version.\n \n     Examples:\n-        'forge-state.json' \u2192 'forge-state.12345.json'\n+        'build-state.json' \u2192 'build-state.12345.json'\n         'completion-checkpoint.json' \u2192 'completion-checkpoint.12345.json'\n \n     Args:\n-        filename: Original filename (e.g., 'forge-state.json')\n+        filename: Original filename (e.g., 'build-state.json')\n         pid: PID to scope to (default: current session PID)\n \n     Returns:\n@@ -110,8 +110,8 @@ def _extract_pid_from_filename(filename: str) -> int | None:\n     \"\"\"Extract PID from a PID-scoped filename.\n \n     Examples:\n-        'forge-state.12345.json' \u2192 12345\n-        'forge-state.json' \u2192 None (legacy, no PID)\n+        'build-state.12345.json' \u2192 12345\n+        'build-state.json' \u2192 None (legacy, no PID)\n \n     Args:\n         filename: Filename (stem or full name)\n@@ -132,11 +132,11 @@ def _extract_pid_from_filename(filename: str) -> int | None:\n def _find_any_scoped_state_files(cwd: str, base_name: str) -> list[Path]:\n     \"\"\"Find all PID-scoped state files matching a base name pattern.\n \n-    Used for session-agnostic checks (e.g., \"is ANY forge session active?\").\n+    Used for session-agnostic checks (e.g., \"is ANY build session active?\").\n \n     Args:\n         cwd: Directory containing .claude/\n-        base_name: Base name without extension (e.g., 'forge-state')\n+        base_name: Base name without extension (e.g., 'build-state')\n \n     Returns:\n         List of matching Path objects, sorted by modification time (newest first)\n@@ -298,7 +298,7 @@ def _check_state_file(cwd: str, filename: str) -> bool:\n     if cwd:\n         current = Path(cwd).resolve()\n         home = Path.home()\n-        base_name = Path(filename).stem  # e.g., 'forge-state'\n+        base_name = Path(filename).stem  # e.g., 'build-state'\n         # Walk up to home directory (max 20 levels to prevent infinite loops)\n         for _ in range(20):\n             # Stop at home directory - ~/.claude/ is for global config, not project state\n@@ -471,8 +471,8 @@ def is_mobileappfix_active(cwd: str, session_id: str = \"\") -> bool:\n     return False\n \n \n-def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if forge mode is active via non-expired state file or env var.\n+def is_build_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if build mode is active via non-expired state file or env var.\n \n     Loads the state file and checks TTL expiry. Expired state files are\n     treated as inactive (cleaned up at next SessionStart).\n@@ -485,34 +485,45 @@ def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if forge mode is active and not expired, False otherwise\n+        True if build mode is active and not expired, False otherwise\n     \"\"\"\n     # Check project-level state with TTL (handles PID-scoped + legacy)\n-    state = load_state_file(cwd, \"forge-state.json\")\n-    if state and not is_state_expired(state):\n-        return True\n+    # Check build-state.json first, fall back to forge-state.json for backward compat\n+    for state_filename in (\"build-state.json\", \"forge-state.json\"):\n+        state = load_state_file(cwd, state_filename)\n+        if state and not is_state_expired(state):\n+            return True\n \n     # Check user-level state with TTL and origin/session check\n-    user_state_path = Path.home() / \".claude\" / \"forge-state.json\"\n-    if user_state_path.exists():\n-        try:\n-            user_state = json.loads(user_state_path.read_text())\n-            if not is_state_expired(user_state) and _is_cwd_under_origin(cwd, user_state, session_id):\n-                return True\n-        except (json.JSONDecodeError, IOError):\n-            pass\n+    for state_filename in (\"build-state.json\", \"forge-state.json\"):\n+        user_state_path = Path.home() / \".claude\" / state_filename\n+        if user_state_path.exists():\n+            try:\n+                user_state = json.loads(user_state_path.read_text())\n+                if not is_state_expired(user_state) and _is_cwd_under_origin(cwd, user_state, session_id):\n+                    return True\n+            except (json.JSONDecodeError, IOError):\n+                pass\n \n     # Fallback: Check environment variable (no TTL for env vars)\n+    if os.environ.get(\"BUILD_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n+        return True\n+    # Legacy env var fallback\n     if os.environ.get(\"FORGE_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n         return True\n \n     return False\n \n \n-# Alias for backward compatibility\n+# Backward compatibility aliases\n+def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Deprecated: Use is_build_active() instead.\"\"\"\n+    return is_build_active(cwd, session_id)\n+\n+\n def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Deprecated: Use is_forge_active() instead.\"\"\"\n-    return is_forge_active(cwd, session_id)\n+    \"\"\"Deprecated: Use is_build_active() instead.\"\"\"\n+    return is_build_active(cwd, session_id)\n \n \n def is_burndown_active(cwd: str, session_id: str = \"\") -> bool:\n@@ -551,19 +562,19 @@ def is_burndown_active(cwd: str, session_id: str = \"\") -> bool:\n \n \n def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if any autonomous execution mode is active (forge, repair, or burndown).\n+    \"\"\"Check if any autonomous execution mode is active (build, repair, or burndown).\n \n     This is the unified check for enabling auto-approval hooks.\n-    Recognizes /forge, /repair (/appfix, /mobileappfix), and /burndown modes.\n+    Recognizes /build, /repair (/appfix, /mobileappfix), and /burndown modes.\n \n     Args:\n         cwd: Current working directory path\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if forge OR repair OR burndown mode is active, False otherwise\n+        True if build OR repair OR burndown mode is active, False otherwise\n     \"\"\"\n-    return is_forge_active(cwd, session_id) or is_repair_active(cwd, session_id) or is_burndown_active(cwd, session_id)\n+    return is_build_active(cwd, session_id) or is_repair_active(cwd, session_id) or is_burndown_active(cwd, session_id)\n \n \n def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n@@ -573,9 +584,9 @@ def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n     similar to how git finds the .git directory.\n \n     Checks in this order at each directory level:\n-    1. PID-scoped file for this session (e.g., forge-state.12345.json)\n+    1. PID-scoped file for this session (e.g., build-state.12345.json)\n     2. Any PID-scoped file with a live PID (another active agent)\n-\n\n... [truncated - diff too long]",
  "existing_docs": [
    "docs/architecture.md",
    "docs/index.md",
    "docs/philosophy.md",
    "README.md",
    ".claude/MEMORIES.md"
  ],
  "instructions": "\nDOCUMENTATION UPDATE TASK\n\nA commit was just made in an repair/build session. Your job is to:\n\n1. Analyze the diff to understand what changed\n2. Determine which documentation files need updating\n3. Update the relevant docs to reflect the changes\n\nCOMMIT MESSAGE:\nfix(hooks): macOS _get_ancestor_pid() basename fix + plan-mode-tracker fallback\n\n- Fix _get_ancestor_pid() on macOS where ps returns full paths (/bin/zsh)\n  instead of just binary names (zsh), causing PID-scoped filenames to be\n  inconsistent across invocations\n- Add legacy forge-state.json fallback in plan-mode-tracker for build\n  state_type, so ExitPlanMode correctly updates existing forge state files\n- Update test to expect build-state (not forge-state) for /godo prompt\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\nEXISTING DOCUMENTATION FILES:\n- docs/architecture.md\n- docs/index.md\n- docs/philosophy.md\n- README.md\n- .claude/MEMORIES.md\n\nDIFF CONTENT:\ncommit 11bee546333f04293942efc895e9f14cf81a7217\nAuthor: olivier-motium <243932812+olivier-motium@users.noreply.github.com>\nDate:   Fri Jan 30 14:37:21 2026 +0100\n\n    fix(hooks): macOS _get_ancestor_pid() basename fix + plan-mode-tracker fallback\n    \n    - Fix _get_ancestor_pid() on macOS where ps returns full paths (/bin/zsh)\n      instead of just binary names (zsh), causing PID-scoped filenames to be\n      inconsistent across invocations\n    - Add legacy forge-state.json fallback in plan-mode-tracker for build\n      state_type, so ExitPlanMode correctly updates existing forge state files\n    - Update test to expect build-state (not forge-state) for /godo prompt\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n---\n config/hooks/_common.py                    | 110 ++++++++++++++++-------------\n config/hooks/plan-mode-tracker.py          |  32 +++++----\n config/hooks/tests/test_plan_mode_hooks.py |   8 +--\n 3 files changed, 84 insertions(+), 66 deletions(-)\n\ndiff --git a/config/hooks/_common.py b/config/hooks/_common.py\nindex 1bcf339..d3409e9 100755\n--- a/config/hooks/_common.py\n+++ b/config/hooks/_common.py\n@@ -90,11 +90,11 @@ def _scoped_filename(filename: str, pid: int | None = None) -> str:\n     \"\"\"Convert a state filename to its PID-scoped version.\n \n     Examples:\n-        'forge-state.json' \u2192 'forge-state.12345.json'\n+        'build-state.json' \u2192 'build-state.12345.json'\n         'completion-checkpoint.json' \u2192 'completion-checkpoint.12345.json'\n \n     Args:\n-        filename: Original filename (e.g., 'forge-state.json')\n+        filename: Original filename (e.g., 'build-state.json')\n         pid: PID to scope to (default: current session PID)\n \n     Returns:\n@@ -110,8 +110,8 @@ def _extract_pid_from_filename(filename: str) -> int | None:\n     \"\"\"Extract PID from a PID-scoped filename.\n \n     Examples:\n-        'forge-state.12345.json' \u2192 12345\n-        'forge-state.json' \u2192 None (legacy, no PID)\n+        'build-state.12345.json' \u2192 12345\n+        'build-state.json' \u2192 None (legacy, no PID)\n \n     Args:\n         filename: Filename (stem or full name)\n@@ -132,11 +132,11 @@ def _extract_pid_from_filename(filename: str) -> int | None:\n def _find_any_scoped_state_files(cwd: str, base_name: str) -> list[Path]:\n     \"\"\"Find all PID-scoped state files matching a base name pattern.\n \n-    Used for session-agnostic checks (e.g., \"is ANY forge session active?\").\n+    Used for session-agnostic checks (e.g., \"is ANY build session active?\").\n \n     Args:\n         cwd: Directory containing .claude/\n-        base_name: Base name without extension (e.g., 'forge-state')\n+        base_name: Base name without extension (e.g., 'build-state')\n \n     Returns:\n         List of matching Path objects, sorted by modification time (newest first)\n@@ -298,7 +298,7 @@ def _check_state_file(cwd: str, filename: str) -> bool:\n     if cwd:\n         current = Path(cwd).resolve()\n         home = Path.home()\n-        base_name = Path(filename).stem  # e.g., 'forge-state'\n+        base_name = Path(filename).stem  # e.g., 'build-state'\n         # Walk up to home directory (max 20 levels to prevent infinite loops)\n         for _ in range(20):\n             # Stop at home directory - ~/.claude/ is for global config, not project state\n@@ -471,8 +471,8 @@ def is_mobileappfix_active(cwd: str, session_id: str = \"\") -> bool:\n     return False\n \n \n-def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if forge mode is active via non-expired state file or env var.\n+def is_build_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Check if build mode is active via non-expired state file or env var.\n \n     Loads the state file and checks TTL expiry. Expired state files are\n     treated as inactive (cleaned up at next SessionStart).\n@@ -485,34 +485,45 @@ def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if forge mode is active and not expired, False otherwise\n+        True if build mode is active and not expired, False otherwise\n     \"\"\"\n     # Check project-level state with TTL (handles PID-scoped + legacy)\n-    state = load_state_file(cwd, \"forge-state.json\")\n-    if state and not is_state_expired(state):\n-        return True\n+    # Check build-state.json first, fall back to forge-state.json for backward compat\n+    for state_filename in (\"build-state.json\", \"forge-state.json\"):\n+        state = load_state_file(cwd, state_filename)\n+        if state and not is_state_expired(state):\n+            return True\n \n     # Check user-level state with TTL and origin/session check\n-    user_state_path = Path.home() / \".claude\" / \"forge-state.json\"\n-    if user_state_path.exists():\n-        try:\n-            user_state = json.loads(user_state_path.read_text())\n-            if not is_state_expired(user_state) and _is_cwd_under_origin(cwd, user_state, session_id):\n-                return True\n-        except (json.JSONDecodeError, IOError):\n-            pass\n+    for state_filename in (\"build-state.json\", \"forge-state.json\"):\n+        user_state_path = Path.home() / \".claude\" / state_filename\n+        if user_state_path.exists():\n+            try:\n+                user_state = json.loads(user_state_path.read_text())\n+                if not is_state_expired(user_state) and _is_cwd_under_origin(cwd, user_state, session_id):\n+                    return True\n+            except (json.JSONDecodeError, IOError):\n+                pass\n \n     # Fallback: Check environment variable (no TTL for env vars)\n+    if os.environ.get(\"BUILD_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n+        return True\n+    # Legacy env var fallback\n     if os.environ.get(\"FORGE_ACTIVE\", \"\").lower() in (\"true\", \"1\", \"yes\"):\n         return True\n \n     return False\n \n \n-# Alias for backward compatibility\n+# Backward compatibility aliases\n+def is_forge_active(cwd: str, session_id: str = \"\") -> bool:\n+    \"\"\"Deprecated: Use is_build_active() instead.\"\"\"\n+    return is_build_active(cwd, session_id)\n+\n+\n def is_godo_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Deprecated: Use is_forge_active() instead.\"\"\"\n-    return is_forge_active(cwd, session_id)\n+    \"\"\"Deprecated: Use is_build_active() instead.\"\"\"\n+    return is_build_active(cwd, session_id)\n \n \n def is_burndown_active(cwd: str, session_id: str = \"\") -> bool:\n@@ -551,19 +562,19 @@ def is_burndown_active(cwd: str, session_id: str = \"\") -> bool:\n \n \n def is_autonomous_mode_active(cwd: str, session_id: str = \"\") -> bool:\n-    \"\"\"Check if any autonomous execution mode is active (forge, repair, or burndown).\n+    \"\"\"Check if any autonomous execution mode is active (build, repair, or burndown).\n \n     This is the unified check for enabling auto-approval hooks.\n-    Recognizes /forge, /repair (/appfix, /mobileappfix), and /burndown modes.\n+    Recognizes /build, /repair (/appfix, /mobileappfix), and /burndown modes.\n \n     Args:\n         cwd: Current working directory path\n         session_id: Current session ID (optional, for cross-directory trust)\n \n     Returns:\n-        True if forge OR repair OR burndown mode is active, False otherwise\n+        True if build OR repair OR burndown mode is active, False otherwise\n     \"\"\"\n-    return is_forge_active(cwd, session_id) or is_repair_active(cwd, session_id) or is_burndown_active(cwd, session_id)\n+    return is_build_active(cwd, session_id) or is_repair_active(cwd, session_id) or is_burndown_active(cwd, session_id)\n \n \n def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n@@ -573,9 +584,9 @@ def _find_state_file_path(cwd: str, filename: str) -> Path | None:\n     similar to how git finds the .git directory.\n \n     Checks in this order at each directory level:\n-    1. PID-scoped file for this session (e.g., forge-state.12345.json)\n+    1. PID-scoped file for this session (e.g., build-state.12345.json)\n     2. Any PID-scoped file with a live PID (another active agent)\n-\n\n... [truncated - diff too long]\n\nINSTRUCTIONS:\n- Only update docs that are actually affected by this change\n- Keep updates concise and accurate\n- Don't add unnecessary documentation\n- If the change is purely code (no architectural/API changes), you may skip doc updates\n- Focus on: API changes, new features, architectural decisions, configuration changes\n\nUse the /heavy skill if you need multiple perspectives on what to document.\n"
}